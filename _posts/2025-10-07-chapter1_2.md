---
title: "Reverse Engineering for Beginners (CH1.2 Some basics)"
date: 2025-10-07 00:00:00 +0800
categories: [Reverse, Books]
tags: [Reverse, Books]
image: "/assets/img/SomeBasics.jpg"
---

<div style="line-height:1.8; font-size:21px;">
<h1  style="color: #9a3ba6; "><b>A short introduction to the CPU</b></h1>
<hr>

<h2 style="color: #3ba2a6; text-align:left;"><b>What is the CPU ?</b></h2>
<hr>

<p>
The author began by explaining what a <b>CPU</b> actually is.  
He defined the <b>CPU</b> as the component responsible for executing <b>Machine Code</b> —  
the low-level instructions that programs are ultimately made of.
</p>

<p>
Then, he clarified a few important terms:
</p>

<h3><b style="color: #b86922;">1. Instruction</b></h3>
<img src="/assets/img/Instruction.png" alt="Instruction" style="display:block; margin:20px auto; border-radius:12px; max-width:80%;">

<p>
An <b>instruction</b> is a simple command that the processor can execute —  
for example, moving data between <b>registers</b> or performing a basic arithmetic operation.  
Each type of processor has its own specific set of instructions that define its architecture.  
This set is called the <b>ISA</b> (Instruction Set Architecture), which will be discussed later.
</p>

<h3><b style="color: #b86922;">2. Machine Code</b></h3>
<img src="/assets/img/machinecode.jpg" alt="machinecode" style="display:block; margin:20px auto; border-radius:12px; max-width:80%;">

<p>
<b>Machine Code</b> is the actual code that the <b>CPU</b> processes directly.  
Each instruction is usually <b>encoded in several bytes</b>.
</p>

<h3><b style="color: #b86922;">3. Assembly Language</b></h3>
<img src="/assets/img/Assembly.jpg" alt="Assembly" style="display:block; margin:20px auto; border-radius:12px; max-width:80%;">

<p>
<b>Assembly Language</b> is a human-readable representation of machine code.  
It uses <b>mnemonic codes</b> and sometimes <b>extensions</b> such as macros.  
It’s designed to make programming at a low level easier for developers.
</p>

<h3><b style="color: #b86922;">4. CPU Registers</b></h3>
<p>
<b>CPU registers</b> are very small and extremely fast storage locations  
used to temporarily hold data during instruction execution.  
Their number is limited — for example, around 8 in <b>x86</b> processors,  
about 16 in <b>x86-64</b>, and roughly 16 in <b>ARM</b>.  
Because of this limitation, programmers must use them carefully.
</p>

<hr>

<h2 style="color: #3ba2a6; text-align:left;"><b>Instruction Set Architectures (ISA)</b></h2>
<hr>

<p>
Every <b>CPU</b> has its own unique instruction set architecture (ISA),  
which defines how it processes instructions.  
The author explained the two most common ones:
</p>

<h3><b style="color: #b86922;">1. x86 Architecture (Intel & AMD)</b></h3>
<img src="/assets/img/Intel-AMD.png" alt="x86 Architecture" style="display:block; margin:20px auto; border-radius:12px; max-width:80%;">
<p>
The <b>x86</b> processors (used by Intel and AMD) have <b>variable-length instructions</b>,  
meaning some instructions are short while others are longer.  
Because of this design, when <b>x64</b> was introduced,  
the change wasn’t very dramatic — they simply added some new features  
but kept the same overall foundation.
</p>

<h3><b style="color: #b86922;">2. ARM Architecture (Used in Mobile and Tablet Devices)</b></h3>
<img src="/assets/img/arm-processor.jpg" alt="ARM Architecture" style="display:block; margin:20px auto; border-radius:12px; max-width:80%;">

<p>
The <b>ARM</b> architecture is based on the <b>RISC</b> (Reduced Instruction Set Computer) concept —  
it uses a smaller, simpler set of instructions.
</p>

<p>
Originally, each instruction in ARM took exactly <b>4 bytes</b>,  
a format known as <b>ARM Mode</b>.  
Later, developers realized that many instructions didn’t need all 4 bytes,  
so they created a <b>2-byte</b> format called <b>Thumb</b>,  
which made the code smaller and faster.
</p>

<p>
After that, ARM introduced <b>Thumb-2</b> (in ARMv7 architecture),  
which combined both 2-byte and 4-byte instructions and added new features.  
This provided the benefits of full ARM mode while keeping efficiency.
</p>

<p>
That’s why most <b>iPhone</b> and <b>iPad</b> applications use it —  
especially since <b>Xcode</b> (Apple’s compiler) does this automatically.
</p>

<p>
Finally, the <b>ARM 64-bit (ARM64)</b> architecture was introduced.  
In this version, all instructions are <b>4 bytes long</b>,  
and the old <b>Thumb</b> mode was completely removed.
</p>

<hr>
<br>

<h1 style="color: #9a3ba6;"><b>Numeral Systems</b></h1>
<hr>
<img src="/assets/img/Numeral_System.jpg" alt="Numeral Systems" style="display:block; margin:20px auto; border-radius:12px; max-width:80%;">

<p>
The author explained that nowadays, the <b>Octal</b> system is almost obsolete,  
except for one main use — <b>file permissions</b> in <b>POSIX</b> systems (like Linux).
</p>

<p>
On the other hand, the <b>Hexadecimal</b> system is used quite often,  
especially when we want to focus on the <b>bit pattern</b> of a value rather than its numerical meaning.
</p>

<p>
He also pointed out that humans are simply used to the <b>decimal system</b>  
because we have ten fingers — but the number “10” itself doesn’t hold any special meaning  
in science or mathematics; it’s just a human convenience.
</p>

<p>
In <b>digital electronics</b>, however, the natural way to represent information is the <b>Binary</b> system,  
because circuits are either carrying current (representing <b>1</b>) or not (representing <b>0</b>).
</p>

<p>
Here are some simple examples:
</p>

<ul>
  <li><b>10</b> in binary = <b>2</b> in decimal</li>
  <li><b>100</b> in binary = <b>4</b> in decimal</li>
</ul>

<p>
If a numeral system has 10 symbols (from 0 to 9),  
then its <b>base (or radix)</b> is 10.  
Meanwhile, the <b>binary</b> system has a base of 2.
</p>

<hr>

<h3 style="color: #b86922;"><b> The author also emphasized two important points to remember :</b></h3>

<ol>
  <li>
    The <b>number</b> itself is the value,  
    but a <b>digit</b> is just a single symbol used to represent part of that number.  
    For example, when you write the number <b>27</b>, the digits “2” and “7” are just symbols —  
    the full number represents the actual value, much like how letters form a complete word that has meaning.
  </li>

  <br>

  <li>
    The <b>value</b> of a number doesn’t change when you convert it between numeral systems —  
    only the <b>representation</b> does.  
    For example, the number that equals “10” in decimal is the same as “1010” in binary  
    and “A” in hexadecimal — it’s the same value, just written differently.
  </li>
</ol>

<hr>
<!-- ---------------------------------------------------------------------------------- -->

<h1 style="color:#9a3ba6;"><b>Converting From One Radix To Another</b></h1>
<img src="/assets/img/Convert_Radix.jpeg" alt="Convert_Radixs" style="display:block; margin:20px auto; border-radius:12px; max-width:70%;">

<hr>

<p>
The author explains that almost all numeral systems use something called <b>Positional Notation</b>, which means every digit in a number has a specific <i>weight</i> or <i>value</i> depending on its position within the number.
</p>

<p>
For instance, if the digit <b>2</b> is on the far right, its value is <b>2</b>. But if it moves one place to the left, its value becomes <b>20</b> — ten times larger simply because its position changed.
</p>

<h3 style="color: #ff8e7f;"><b>Example: 1234</b></h3>

<pre style="background:#222; color:#eee; padding:12px; border-radius:10px; font-size:17px;">
1 × 10³ + 2 × 10² + 3 × 10¹ + 4 × 10⁰
= 1000 + 200 + 30 + 4 = 1234
</pre>

<p>
In <b>binary</b>, the idea is exactly the same, except the base is <b>2</b> instead of <b>10</b>.
</p>

<ul>
  <li>The first position = 1</li>
  <li>The next = 2</li>
  <li>Then 4</li>
  <li>Then 8, and so on...</li>
</ul>

<p>
So if we take the binary number <b>101011</b>:
</p>

<pre style="background:#222; color:#eee; padding:12px; border-radius:10px; font-size:17px;">
1×2⁵ + 0×2⁴ + 1×2³ + 0×2² + 1×2¹ + 1×2⁰
= 32 + 0 + 8 + 0 + 2 + 1 = 43
</pre>

<p>
Each bit is multiplied by 2 raised to its position number, and when you sum them up, the result in decimal is <b>43</b>.
</p>

<p>
He also mentioned that ancient systems like the <b>Roman numerals</b> didn’t use positional notation.  
For example, the number 4 was written as <b>IV</b>, which made arithmetic operations quite difficult.  
That’s why positional systems became so important and widely used.
</p>

<p>
And since binary numbers are often long and repetitive, programmers came up with the <b>Hexadecimal</b> system, which simply groups <b>4 bits</b> into one symbol.
</p>

<p>
For example, the binary number <code>1111</code> equals the hexadecimal <code>F</code>.
</p>

<hr>

<h2 style="color:#9a3ba6;"><b>Hexadecimal Conversion Table</b></h2>

<table style="width:90%; margin:auto; border-collapse:collapse; text-align:center; font-family:'Cascadia Code', monospace; background:#1e1e2e; color:#e0e0e0; border-radius:12px; overflow:hidden; box-shadow:0 0 10px rgba(0,0,0,0.3);">
  <thead style="background:#9a3ba6; color:#fff;">
    <tr>
      <th style="padding:10px;">Hexadecimal</th>
      <th style="padding:10px;">Binary</th>
      <th style="padding:10px;">Decimal</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>0</td><td>0000</td><td>0</td></tr>
    <tr><td>1</td><td>0001</td><td>1</td></tr>
    <tr><td>2</td><td>0010</td><td>2</td></tr>
    <tr><td>3</td><td>0011</td><td>3</td></tr>
    <tr><td>4</td><td>0100</td><td>4</td></tr>
    <tr><td>5</td><td>0101</td><td>5</td></tr>
    <tr><td>6</td><td>0110</td><td>6</td></tr>
    <tr><td>7</td><td>0111</td><td>7</td></tr>
    <tr><td>8</td><td>1000</td><td>8</td></tr>
    <tr><td>9</td><td>1001</td><td>9</td></tr>
    <tr><td>A</td><td>1010</td><td>10</td></tr>
    <tr><td>B</td><td>1011</td><td>11</td></tr>
    <tr><td>C</td><td>1100</td><td>12</td></tr>
    <tr><td>D</td><td>1101</td><td>13</td></tr>
    <tr><td>E</td><td>1110</td><td>14</td></tr>
    <tr><td>F</td><td>1111</td><td>15</td></tr>
  </tbody>
</table>

<p>
Now, how can we tell which numeral system a number belongs to?
</p>

<ul>
  <li>
    <b style="color: #258644;">Decimal:</b> Written normally like <code>1234</code>.  
    However, in some assemblers, the suffix <b>d</b> is added, like <code>1234d</code>.
  </li>
  <li>
    <b style="color: #258644;">Binary:</b> Can appear in two ways — either prefixed with <b>0b</b> (like <code>0b100110111</code>)  
    or with a trailing <b>b</b> (like <code>100110111b</code>).  
    The book uses the <b>0b</b> format in all examples.
  </li>
  <li>
    <b style="color: #258644;">Hexadecimal:</b> Usually starts with <b>0x</b> (like <code>0x1234CD</code>) — common in C/C++.  
    It can also end with an <b>h</b> (like <code>1234CDh</code>), which is popular in assemblers and debuggers.  
    If the number starts with a letter (A–F), a leading zero is added (e.g., <code>0ABCDEFh</code>) to avoid confusion with variables.  
    In older machines, the <b>$</b> symbol was sometimes used before the number (like <code>$ABCD</code>).  
    The book uses the unified <b>0x</b> notation.
  </li>
  <li>
    <b style="color: #258644;">Octal:</b> This system (digits 0–7) was used heavily in older computers.  
    Each digit represents 3 bits, which made binary–octal conversion easy.  
    Nowadays, it’s mostly replaced by hexadecimal, except in <b>UNIX / Linux</b> systems — particularly in the <code>chmod</code> command.
  </li>
</ul>

<hr>

<h2 style="color:#9a3ba6;"><b>File Permissions in Octal (chmod)</b></h2>

<p>
The <code>chmod</code> command takes a <b>three-digit octal number</b> as input.  
Each digit represents permissions for <b>owner</b>, <b>group</b>, and <b>others</b>.
</p>

<table style="width:70%; margin:auto; border-collapse:collapse; text-align:center; font-family:'Cascadia Code', monospace; background:#1e1e2e; color:#e0e0e0; border-radius:12px; overflow:hidden; box-shadow:0 0 10px rgba(0,0,0,0.3);">
  <thead style="background:#9a3ba6; color:#fff;">
    <tr>
      <th style="padding:10px;">Decimal</th>
      <th style="padding:10px;">Binary</th>
      <th style="padding:10px;">Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>7</td><td>111</td><td>rwx</td></tr>
    <tr><td>6</td><td>110</td><td>rw-</td></tr>
    <tr><td>5</td><td>101</td><td>r-x</td></tr>
    <tr><td>4</td><td>100</td><td>r--</td></tr>
    <tr><td>3</td><td>011</td><td>-wx</td></tr>
    <tr><td>2</td><td>010</td><td>-w-</td></tr>
    <tr><td>1</td><td>001</td><td>--x</td></tr>
    <tr><td>0</td><td>000</td><td>---</td></tr>
  </tbody>
</table>

<p>
Each bit represents a permission: <b>read (r)</b>, <b>write (w)</b>, or <b>execute (x)</b>.
</p>

<p>
For example:
</p>
<!------------------------------------ Code ---------------------- -->
<div style="background:#0d1117;color:#e6edf3;font-family:'Fira Code',monospace;border-radius:12px;overflow:hidden;margin:1.5rem 0;box-shadow:0 0 15px rgba(0,0,0,0.5);border:1px solid #30363d;">
  <!-- Header bar -->
  <div style="background:#161b22;display:flex;align-items:center;justify-content:space-between;padding:0.6rem 1rem;">
    <div style="display:flex;gap:6px;">
      <span style='width:12px;height:12px;border-radius:50%;background:#ff5f56;'></span>
      <span style='width:12px;height:12px;border-radius:50%;background:#ffbd2e;'></span>
      <span style='width:12px;height:12px;border-radius:50%;background:#27c93f;'></span>
    </div>
    <span style="font-size:0.9rem;color:#8b949e;">Terminal</span>
    <button onclick="navigator.clipboard.writeText(this.parentElement.nextElementSibling.innerText);this.innerText='Copied!';setTimeout(()=>this.innerText='Copy',2000);" style="background:#21262d;border:1px solid #30363d;color:#8b949e;font-size:0.8rem;padding:3px 8px;border-radius:6px;cursor:pointer;transition:all 0.2s;">Copy</button>
  </div>

  <!-- Code content -->
  <pre style="margin:0;padding:1rem;font-size:15px;line-height:1.6;overflow-x:auto;">
<code style="color:#79c0ff;">$</code> <code>chmod 644 file</code>
  </pre>
</div>

<!-- ----------------------------- --------------------------------------->
<p>
Converted to binary, this is <b>110100100</b>, which we can divide into three groups of 3 bits:
</p>

<pre style="background:#222; color:#eee; padding:12px; border-radius:10px; font-size:17px;">
110 100 100
</pre>

<p>
Each group defines the permissions:
</p>

<ul>
  <li><b>6</b> → owner → <code>rw-</code></li>
  <li><b>4</b> → group → <code>r--</code></li>
  <li><b>4</b> → others → <code>r--</code></li>
</ul>

<p>
Older systems like the <b>PDP-8</b> used word sizes of 12, 24, or 36 bits — all divisible by 3, making <b>octal</b> convenient.  
Modern CPUs use 16, 32, or 64 bits (divisible by 4), which is why <b>hexadecimal</b> replaced it.
</p>

<p>
In <b>C/C++</b>, if you write a number starting with <code>0</code> (like <code>0377</code>), it’s treated as <b>octal</b>.  
So <code>09</code> would throw an error since <b>7</b> is the highest valid digit in octal.
</p>

<p>
Also, when using disassemblers like <b>IDA</b> or <b>JAD</b> for Java code,  
you might see non-printable characters represented in <b>octal</b> instead of hexadecimal.
</p>

<hr>

<h1 style="color:#9a3ba6;"><b>Divisibility</b></h1>
<img src="/assets/img/Convert_Radix.jpeg" alt="Convert_Radixs" style="display:block; margin:20px auto; border-radius:12px; max-width:70%;">

<p>
This concept is quite simple.  
If you look at the number <b>120</b>, you instantly know it’s divisible by 10 because it ends with a zero.  
Similarly, <b>14300</b> is divisible by 100 since it ends with two zeros.
</p>

<p>
The same logic applies to <b>hexadecimal</b> numbers:  
If you see <b>0x1230</b>, it’s divisible by <b>0x10</b>;  
if it’s <b>0x12300</b>, then it’s divisible by <b>0x100</b>.
</p>

<p>
And in <b>binary</b>, it’s similar:  
<code>0b10000101000</code> is divisible by <code>0b1000</code>.
</p>

<p>
This is useful for quickly identifying whether an address or memory block size is <b>aligned (padded)</b>.  
For example, in <b>PE files</b>, sections usually start at addresses ending with three hexadecimal zeros:
</p>

<pre style="background:#222; color:#eee; padding:12px; border-radius:10px; font-size:17px;">
0x41000
0x10001000
</pre>

<p>
That’s because most sections are aligned to <b>0x1000</b> boundaries.
</p>

<hr>

<h1 style="color:#9a3ba6;"><b>Multi-Precision Arithmetic and Radix</b></h1>
<img src="/assets/img/Multi-Precision Arithmetic and Radix.png" alt="Multi-Precision Arithmetic and Radix" style="display:block; margin:20px auto; border-radius:12px; max-width:70%;">

<p>
Let’s simplify this one too.  
When a computer performs very precise calculations with huge numbers,  
the processor can’t fit them into a normal integer type.
</p>

<p>
For example, <b>RSA encryption keys</b> can be thousands of bits long.  
To handle this, the large number is split into smaller parts,  
each treated as a separate “digit” in a base such as <b>2⁸</b> or <b>2³²</b>.
</p>

</div>
